                               ---------------------
                               CREDENTIAL ASSERTIONS
                               ---------------------


INTRODUCTION
------------

For each action submitted to admission control assertions are generated that
will be checked against the conditions specified in the credentials. This
document provides information about the assertions generated by admission
control.


NAME-VALUE PAIR ASSERTIONS
--------------------------

For each name-value pair action submitted to admission control an assertion of
the format shown below is generated.

(name) = (value)

A timestamp assertion named "TIMESTAMP" is generated automatically, to be used
as an "expiration date" for the credentials. For example putting the following
condition in a set of credentials, will "invalidate" them after the 14th of
January 2005.

TIMESTAMP <= "1105657200" 

It is also a good idea to specify an application domain for the credentials, so
as to not confuse different applications using admission control. Any name
could be chosen for the action. For example:

app_domain = "MAPI" or app_domain = "FFPF"


FUNCTION ASSERTIONS
-------------------

For each function action submitted to admission control there is a set of
assertions generated. There are 2 kind of assertions generated. The 1st focuses
on function types providing some statistical assertions, while the 2nd focus on
each function action/instance providing more detailed data.


STATISTICAL ASSERTIONS

Function is defined:
	(function_name) = "defined"
	e.g. PKT_COUNTER = "defined"
	(function_name).(lib_name) = "defined"
	$("PKT_COUNTER.STDLIB") = "defined"

Number of function instances:
	(function_name).num = (number_of_instances)
	e.g. @$("PKT_COUNTER.num") = 2
	(function_name).(lib_name).num = (number_of_instances)
	e.g. @$("PKT_COUNTER.STDLIB.num") = 2

Position of function in function list (numbering starts at 0):
	(function_name).first = (position)
	(function_name).last = (position)
	e.g. @$("PKT_COUNTER.first") = 0
	(function_name).(library_name).first = (position)
	(function_name).(library_name).last = (position)
	e.g. @$("PKT_COUNTER.STDLIB.first") = 0

Function parameter values range (for strings the length is used, functions don't
generate min/max assertions):
	(function_name).param.(parameter_no).max = (max)
	(function_name).param.(parameter_no).min = (min)
	e.g. @$("TO_FILE.param.0.max") = 24
	(function_name).(lib_name).param.(parameter_no).min = (min)
	(function_name).(lib_name).param.(parameter_no).max = (max)
	e.g. @$("TO_FILE.STDLIB.param.0.max") = 24


FUNCTION INSTANCES ASSERTIONS

Position of instance (numbering starts at 0):
	(function_name).(instance_no).pos = (position)
	func.(function_position)_name = (function_name)
	e.g. @$("PKT_COUNTER.0.pos") = 0, @$("func.0.name") = "PKT_COUNTER"

Instance parameter values (for strings the length is used):
	(function_name).(instance_no).param.(parameter_no) = (value)
	func.(function_position).param.(parameter_no) = (value)
	e.g. @$("TO_FILE.0.param.0") = 24, @$("func.0.param.1") = 24

NOTE: When writing conditions, assertions that are not generated because a
function has not been used, are considered to default to 0. This means that if
a condition requires an argument to be greather than zero, it is required to
also check that the function has been defined. So the condition should be
written as: 
((function_name) != "defined" || (function_name).param.(parameter_no).min > 0)
If the function is not defined then the second condition is not evaluated.



EXAMPLES
--------

Having the above in mind some example conditions are shown below.
	
Conditions: app_domain == "MAPI" && device_name ~= "eth[0-9]" &&
	@$("PKT_COUNTER.num") < 2 && @$("BYTE_COUNTER.num") < 2 &&
	$("TO_TCPDUMP.param.1.max") < "847759389305035"
	-> "true";

In these conditions the operator '~=' causes the assertion to be checked using
regular expressions. Assertion names including dots need to be referenced as
$("name.rest"). The '@' prefix indicates that the value of the assertion should
be treated as an integer. '&' can be used for floats. For large numbers like
unsigned long or even unsigned long long lexicographic comparison should be
used as shown in the example.

To get more information on how to write credentials read the keynote(4) and
keynote(5) man pages.